# backend_pms.py

import psycopg2
import os

# --- Database Connection ---
# It's recommended to use environment variables for database credentials in production.
# For simplicity, we are using them directly here.
DB_NAME = "pmsnew"
DB_USER = "postgres"
DB_PASSWORD = "Tulika30@xime"
DB_HOST = "localhost"
DB_PORT = "5432"

def get_db_connection():
    """Establishes and returns a connection to the PostgreSQL database."""
    conn = psycopg2.connect(
        dbname=DB_NAME,
        user=DB_USER,
        password=DB_PASSWORD,
        host=DB_HOST,
        port=DB_PORT
    )
    return conn

 # --- CRUD for Projects ---
    def create_project(self, name, start_date, due_date):
        project_id = str(uuid.uuid4())
        self.cur.execute(
            "INSERT INTO projects (project_id, project_name, start_date, due_date) VALUES (%s, %s, %s, %s);",
            (project_id, name, start_date, due_date)
        )
        self.conn.commit()

    def read_all_projects(self):
        self.cur.execute("SELECT project_id, project_name FROM projects ORDER BY project_name;")
        return self.cur.fetchall()

    # --- CRUD for Team Members ---
    def create_member(self, name, role):
        member_id = str(uuid.uuid4())
        self.cur.execute(
            "INSERT INTO team_members (member_id, member_name, role) VALUES (%s, %s, %s);",
            (member_id, name, role)
        )
        self.conn.commit()

    def read_all_members(self):
        self.cur.execute("SELECT member_id, member_name FROM team_members ORDER BY member_name;")
        return self.cur.fetchall()

    # --- CRUD for Tasks ---
    def create_task(self, project_id, member_id, description, status, hours):
        task_id = str(uuid.uuid4())
        self.cur.execute(
            "INSERT INTO tasks (task_id, project_id, assigned_to_member_id, task_description, status, estimated_hours) VALUES (%s, %s, %s, %s, %s, %s);",
            (task_id, project_id, member_id, description, status, hours)
        )
        self.conn.commit()

    def read_tasks_for_project(self, project_id):
        query = """
        SELECT t.task_id, t.task_description, tm.member_name, t.status, t.estimated_hours
        FROM tasks t
        JOIN team_members tm ON t.assigned_to_member_id = tm.member_id
        WHERE t.project_id = %s
        ORDER BY t.status;
        """
        self.cur.execute(query, (project_id,))
        return self.cur.fetchall()

    def update_task_status(self, task_id, new_status):
        self.cur.execute("UPDATE tasks SET status = %s WHERE task_id = %s;", (new_status, task_id))
        self.conn.commit()

    # --- Business Insights & Aggregations ---
    def get_project_insights(self, project_id):
        """Calculates all key metrics for a given project dashboard."""
        insights = {}
        # COUNT: Total tasks
        self.cur.execute("SELECT COUNT(*) FROM tasks WHERE project_id = %s;", (project_id,))
        insights['total_tasks'] = self.cur.fetchone()[0]

        # COUNT: Done tasks
        self.cur.execute("SELECT COUNT(*) FROM tasks WHERE project_id = %s AND status = 'Done';", (project_id,))
        insights['done_tasks'] = self.cur.fetchone()[0]

        # SUM: Total hours
        self.cur.execute("SELECT SUM(estimated_hours) FROM tasks WHERE project_id = %s;", (project_id,))
        insights['total_hours'] = self.cur.fetchone()[0] or 0

        # AVG: Average hours
        self.cur.execute("SELECT AVG(estimated_hours) FROM tasks WHERE project_id = %s;", (project_id,))
        insights['avg_hours'] = self.cur.fetchone()[0] or 0

        # MIN: Min hours
        self.cur.execute("SELECT MIN(estimated_hours) FROM tasks WHERE project_id = %s;", (project_id,))
        insights['min_hours'] = self.cur.fetchone()[0] or 0

        # MAX: Max hours
        self.cur.execute("SELECT MAX(estimated_hours) FROM tasks WHERE project_id = %s;", (project_id,))
        insights['max_hours'] = self.cur.fetchone()[0] or 0

        return insights

    def __del__(self):
        """Closes the database connection upon object destruction."""
        if hasattr(self, 'cur'): self.cur.close()
        if hasattr(self, 'conn'): self.conn.close()
